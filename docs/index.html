<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Monte Carlo Integration Library: Montecarlo Integration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Monte Carlo Integration Library<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">High-performance Monte Carlo methods for numerical integration and optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Montecarlo Integration </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a>This project implements a Monte Carlo integration algorithm in C++ to calculate definite integrals over N-dimensional hyperspheres and hyperrectangles. The software can use the <b>muParserX</b> library to parse mathematical functions at runtime.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
üöÄ Build and Run</h1>
<p>Ensure you have CMake, a C++ compiler, and muParserX installed. <br  />
 From the root of the project: <br  />
</p>
<ol type="1">
<li>Create the build directory and enter it: <div class="fragment"><div class="line">mkdir build</div>
</div><!-- fragment --></li>
<li>Generate the build files: <div class="fragment"><div class="line">cmake ..</div>
</div><!-- fragment --></li>
<li>Compile the project: <div class="fragment"><div class="line">make</div>
</div><!-- fragment --></li>
<li>Run the executable: <div class="fragment"><div class="line">./montecarlo_1</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md2"></a>
üìö Documentation</h1>
<p>Full API documentation is available via Doxygen:</p>
<div class="fragment"><div class="line"># Generate documentation (requires doxygen and graphviz)</div>
<div class="line">doxygen Doxyfile</div>
<div class="line"> </div>
<div class="line"># Open in browser</div>
<div class="line">open docs/html/index.html  # macOS</div>
<div class="line">xdg-open docs/html/index.html  # Linux</div>
</div><!-- fragment --><p>See DOXYGEN_GUIDE.md for detailed instructions.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
‚öôÔ∏è Run Modes</h1>
<p>The project offers several run modes, divided into two main executables (<code>montecarlo_1</code> for benchmarks/tests and <code>drone_optimization</code> for the specific application):</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Mode 1: Parser-Based Integration (Function from File)</h2>
<p><em>Executable: <code>montecarlo_1</code></em> Uses the mathematical expression from <code>function.txt</code> via the <b>muParserX</b> library.</p>
<p><b>Use case:</b> When you want to test custom functions without recompiling. <br  />
 <b>Performance:</b> Slower due to runtime parsing overhead (~2-10x slower than hardcoded). <br  />
 <b>Gnuplot:</b> Supports visualization (1D, 2D, 3D only). <br  />
 <b>Domains tested:</b> Hypersphere, Hyperrectangle, Hypercylinder across various dimensions.</p>
<p><b>How it works:</b> The parser reads your function expression from <code>function.txt</code> and performs Monte Carlo integration using <b>uniform sampling</b> over multiple geometric domains. Test functions include:</p><ul>
<li>1D: $\sin(x)$</li>
<li>2D: $\sin(x)\cos(y)$, $x^2 + y^2$</li>
<li>3D+: Higher-dimensional polynomial and trigonometric combinations</li>
<li>Up to 12D: Scaling tests on high-dimensional spaces</li>
</ul>
<p><b>Benchmark output:</b> Generates tables comparing sample counts (100, 1K, 10K, 100K, 1M) and execution times, with Gnuplot visualization of convergence.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Mode 2: Hardcoded Integration with Importance Sampling</h2>
<p><em>Executable: <code>montecarlo_1</code></em> Uses pre-compiled C++ lambda functions with multiple integration strategies.</p>
<p><b>Use case:</b> When performance is critical and you're working with fixed test functions. Ideal for variance reduction studies. <br  />
 <b>Performance:</b> Fast (no parsing overhead; ~10-100x faster than Mode 1). <br  />
 <b>Gnuplot:</b> Supports visualization (1D, 2D, 3D only). <br  />
 <b>Domains tested:</b> Hypersphere, Hyperrectangle, Hypercylinder, various dimensions up to 12D.</p>
<p><b>Integration methods tested:</b></p><ol type="1">
<li><b>Normal Sampling (Classic MC)</b>: Baseline uniform rejection sampling</li>
<li><b>Uniform Importance Sampling</b>: Flat proposal over bounding box (sanity check)</li>
<li><b>Gaussian Importance Sampling</b>: Isotropic Gaussian centered at domain centroid</li>
<li><b>Mixture Importance Sampling</b>: 50/50 blend of Gaussian + Uniform</li>
</ol>
<p><b>Test functions include:</b></p><ul>
<li>Circle area (2D): $\int\int_{x^2+y^2 \leq 1} 1 \, dx dy$</li>
<li>3D Sphere volume: $\int\int\int_{|\mathbf{x}| \leq 1} 1 \, d\mathbf{x}$</li>
<li>Smooth integrands: $\sin(x)\cos(y)$, $e^{-(x^2+y^2)}$</li>
<li>Polynomial: $x^2 + y^2$ over rectangular domains</li>
</ul>
<p><b>Benchmark output:</b> For each domain, runs all 4 methods across sample counts (100‚Üí1M) and reports execution times and convergence rates. Saves results to <code>results_seed_*.txt</code> files.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Mode 3: Hardcoded Integration (Metropolis-Hastings MCMC)</h2>
<p><em>Executable: <code>montecarlo_1</code></em> Uses pre-compiled C++ lambda functions with Metropolis-Hastings Markov Chain Monte Carlo sampling.</p>
<p><b>Use case:</b> For complex or high-dimensional domains where uniform sampling is inefficient. Excellent for non-convex geometries. <br  />
 <b>Performance:</b> Fast (compiled), with superior O(1/N) convergence vs O(1/‚àöN) for classic MC. <br  />
 <b>Gnuplot:</b> Supports visualization (1D, 2D, 3D only). <br  />
 <b>Domains tested:</b> Hypersphere, Hyperrectangle, Hypercylinder.</p>
<p><b>Algorithm:</b></p><ol type="1">
<li><b>Volume Estimation</b>: Hit-or-Miss Monte Carlo (classic rejection sampling)</li>
<li><b>Mean Estimation</b>: Metropolis-Hastings random walk with symmetric proposals<ul>
<li>Proposal: $\mathbf{x}' = \mathbf{x} + \mathcal{N}(0, \sigma^2)$</li>
<li>Acceptance: $\alpha = \min(1, \frac{\pi(\mathbf{x}')}{\pi(\mathbf{x})})$ (uniform target density)</li>
</ul>
</li>
<li><b>Integral</b>: $I = V_{\Omega} \times \bar{f}$ (volume √ó mean of function values)</li>
</ol>
<p><b>Configuration:</b></p><ul>
<li>Burn-in: 20% of samples (discarded for convergence)</li>
<li>Thinning: Factor of 2 (reduces autocorrelation)</li>
<li>Proposal deviation: Auto-tuned from domain size</li>
</ul>
<p><b>Benchmark output:</b> Compares MH vs classic MC across same sample counts, showing convergence rates and acceptance statistics.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Mode 4: Polytope Integration (Convex Hull via Qhull)</h2>
<p><em>Executable: <code>montecarlo_1</code></em> Integrates over arbitrary convex polytopes defined by user-provided points.</p>
<p><b>Use case:</b> When your integration domain is a convex polytope (e.g., polyhedron in 3D, 4D+ convex polytope). <br  />
 <b>Performance:</b> O(N √ó F) where N = samples, F = number of facets. Scales well for moderate polytope complexity. <br  />
 <b>Gnuplot:</b> Not applicable (higher-dimensional geometries). <br  />
 <b>Input files:</b> <code>points.txt</code> (vertices), <code>hull.txt</code> (facet normals + offsets from Qhull).</p>
<p><b>How it works:</b></p><ol type="1">
<li>Reads vertex coordinates from <code>points.txt</code></li>
<li>Uses Qhull-computed facet normals/offsets from <code>hull.txt</code> (half-space representation)</li>
<li>Performs uniform MC rejection sampling: point is "in polytope" if it satisfies ALL half-space inequalities</li>
<li>Formula: $I = V_P \times \frac{1}{N} \sum_{i=1}^{N} f(\mathbf{x}_i) \times \mathbb{1}_P(\mathbf{x}_i)$</li>
</ol>
<p>**Input format (<code>points.txt</code>):** </p><div class="fragment"><div class="line">&lt;num_points&gt; &lt;dim&gt;</div>
<div class="line">x‚ÇÅ‚ÇÅ x‚ÇÅ‚ÇÇ ... x‚ÇÅ‚Çê</div>
<div class="line">x‚ÇÇ‚ÇÅ x‚ÇÇ‚ÇÇ ... x‚ÇÇ‚Çê</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>Qhull command:</b> </p><div class="fragment"><div class="line">qhull Qt n &lt; points.txt &gt; hull.txt   # Qt=triangulate, n=facet normals + offsets</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Mode 5: Particle Swarm Optimization (PSO) Benchmarks</h2>
<p><em>Executable: <code>montecarlo_1</code></em> Runs optimization benchmarks using the Particle Swarm Optimization algorithm.</p>
<p><b>Use case:</b> Finding global minima of continuous, smooth optimization landscapes. <br  />
 <b>Performance:</b> 10-100x faster than GA for smooth functions; excellent scaling to high dimensions. <br  />
 <b>Gnuplot:</b> Auto-generates convergence plots (<code>run_pso.gp</code>, <code>run_pso_3d.gp</code>). <br  />
 <b>Benchmark functions:</b></p><ul>
<li><b>Sphere</b>: $f(x) = \sum_{i=1}^{d} x_i^2$ (global minimum: 0 at origin)</li>
<li><b>Rastrigin</b>: $f(x) = 10d + \sum_{i=1}^{d} [x_i^2 - 10\cos(2\pi x_i)]$ (multimodal, many local minima)</li>
<li><b>Rosenbrock</b>: $f(x) = \sum_{i=1}^{d-1} [100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2]$ (narrow valley)</li>
</ul>
<p><b>Algorithm configuration:</b></p><ul>
<li>Particles: 30</li>
<li>Iterations: 100</li>
<li>Inertia weight: 0.6</li>
<li>Cognitive parameter (c‚ÇÅ): 1.8</li>
<li>Social parameter (c‚ÇÇ): 2.0</li>
<li>Search space: typically [-10, 10]·µà per dimension</li>
</ul>
<p><b>Output:</b> Convergence plots showing best fitness vs iteration, comparison with GA results.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Mode 6: Genetic Algorithm (GA) Benchmarks</h2>
<p><em>Executable: <code>montecarlo_1</code></em> Runs optimization benchmarks using a Genetic Algorithm.</p>
<p><b>Use case:</b> Finding global minima for non-smooth, noisy, or discrete-variable problems. <br  />
 <b>Performance:</b> More robust than PSO for multimodal landscapes; slower on smooth functions. <br  />
 <b>Gnuplot:</b> Auto-generates convergence plots (<code>run_ga.gp</code>, <code>run_ga_3d.gp</code>). <br  />
 <b>Benchmark functions:</b> Same as PSO (Sphere, Rastrigin, Rosenbrock) for direct comparison.</p>
<p><b>Algorithm configuration:</b></p><ul>
<li>Population size: 50</li>
<li>Generations: 150</li>
<li>Tournament selection: k=3 (select best of 3 random individuals)</li>
<li>Crossover rate: 0.9 (probability per dimension)</li>
<li>Mutation rate: 0.1 (Gaussian noise $\mathcal{N}(0, \sigma^2)$)</li>
<li>Elitism: 2 (top 2 individuals carried to next generation)</li>
</ul>
<p><b>Output:</b> Convergence curves, final best solution, comparison vs PSO on same test functions.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Mode 7: Drone Arm Center of Mass Optimization</h2>
<p><em>Executable: <code>drone_optimization</code></em> Specialized application combining Monte Carlo integration with PSO for geometric optimization.</p>
<p><b>Use case:</b> Optimizing hole placement and size in a drone arm to achieve target center of mass. <br  />
 <b>Performance:</b> Parallelized PSO with OpenMP thread management (~10x speedup on 8 cores). <br  />
 <b>Output:</b> High-precision verification with 1M samples, auto-generated 3D visualization script.</p>
<p><b>Physical domain (3D):</b></p><ul>
<li>Rectangular arm: 10m √ó 1m √ó 1m aligned along x-axis</li>
<li>Cylindrical motor: radius 0.5m, height 2m (mounted at x=2m)</li>
<li>Optional cabin: convex polytope (configurable via polytope input files)</li>
</ul>
<p><b>Optimization problem:</b></p><ul>
<li><b>Decision variables</b>: Hole center position $(x_h, y_h, z_h)$ and radius $r$</li>
<li><b>Objective</b>: Find $(x_h, y_h, z_h, r)$ such that center of mass shifts to target $(1.0, 0, 0)$</li>
<li><b>Constraints</b>: Hole must stay within arm geometry (boundary checking)</li>
</ul>
<p><b>Algorithm phases:</b></p><ol type="1">
<li><b>Fast optimization</b> (20K samples): PSO explores parameter space, ~30 iterations</li>
<li><b>High-precision verification</b> (1M samples): Monte Carlo re-validates best solution found</li>
<li><b>Hybrid verification</b>: Compares Monte Carlo baseline vs analytical hole subtraction (&lt; 0.1% error expected)</li>
</ol>
<p><b>Output files:</b></p><ul>
<li><code>drone_frames/drone_domain.txt</code>: Sampled points on geometry (for visualization)</li>
<li><code>visualize_drone.gp</code>: Auto-generated Gnuplot script for 3D rendering</li>
<li><code>optimization_log.txt</code>: Per-iteration PSO statistics</li>
<li><code>final_solution.txt</code>: Optimal hole parameters and final center of mass</li>
</ul>
<p><b>Thread management:</b></p><ul>
<li>Parallelized particle evaluation with OpenMP</li>
<li>Thread-safe RNG management via per-thread sub-seeds</li>
<li>Control threads via: <code>./drone_optimization [seed] [num_threads]</code></li>
</ul>
<p><b>Key Results:</b> <br  />
 The optimization successfully balances the drone arm achieving:</p><ul>
<li><b>Target COM</b>: (1.0, 0, 0)</li>
<li><b>Achieved COM</b>: ~(0.99, 0, 0)</li>
<li><b>Error</b>: &lt; 1% (&lt; 0.01m on 10m arm)</li>
<li><b>Hybrid Verification Delta</b>: &lt; 0.1% (Monte Carlo baseline vs analytical subtraction)</li>
</ul>
<p>This confirms high fidelity and robustness of the stochastic solver.</p>
<p><b>Visualization:</b> <br  />
 After running, the script automatically generates <code>visualize_drone.gp</code>: </p><div class="fragment"><div class="line">gnuplot -persist visualize_drone.gp  # Visualize the drone geometry</div>
</div><!-- fragment --><p><b>Images of the domain:</b> <br  />
 *(Note: The images below are from a similar simulation setup to clearly illustrate the hole placement; specific dimensions in the current build may vary slightly.)*</p>
<p><img src="assets/drone_domain_view.png" alt="Drone domain view" width="48%" class="inline"/> <img src="assets/drone_domain_hole.png" alt="Drone domain hole detail" width="48%" class="inline"/> </p>
<p><b>Command line:</b> </p><div class="fragment"><div class="line">./drone_optimization [seed] [num_threads]</div>
</div><!-- fragment --><ul>
<li><code>seed</code>: Random seed (optional, default: 12345; use <code>-</code> to keep default when specifying threads)</li>
<li><code>num_threads</code>: Number of threads (optional, default: max available; 0 = sequential for performance comparison)</li>
</ul>
<p><b>Examples:</b> </p><div class="fragment"><div class="line">./drone_optimization                 # Run with default seed and max threads</div>
<div class="line">./drone_optimization 42 4            # Run with seed 42 using 4 threads</div>
<div class="line">./drone_optimization - 4             # Run with default seed using 4 threads</div>
<div class="line">./drone_optimization 42 0            # Run with seed 42 sequentially (single thread)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Mode 8: Wind Farm Layout Optimization</h2>
<p><em>Executable: <code>wind_farm_simulator</code></em> Optimizes wind turbine placement using hybrid Metropolis-Hastings Monte Carlo integration combined with PSO and Genetic Algorithm.</p>
<p><b>Use case:</b> Finding the optimal layout of wind turbines in a farm to maximize power generation while respecting minimum distance constraints. <br  />
 <b>Performance:</b> Parallel MH integration with OpenMP thread-safe RNG and optimizers running PSO vs GA comparison. <br  />
 <b>Output:</b> Optimized turbine positions, convergence plots, and wind farm layout visualizations.</p>
<p><b>How it works:</b></p><ul>
<li>Models a 1000m √ó 1000m wind farm with 15 turbines</li>
<li>Uses Weibull wind speed distribution and wake effects between turbines</li>
<li>Employs Metropolis-Hastings integration to estimate average farm power given a turbine layout</li>
<li>Optimizes turbine positions (x, y for each turbine) using both PSO and GA</li>
<li>Enforces minimum 50m distance between turbines via penalty function</li>
<li>Accounts for wind speed reduction downstream of turbines (wake effect)</li>
<li>Models turbine power output based on wind speed, rotor area, air density, and power coefficient</li>
</ul>
<p><b>Physical Model:</b></p><ul>
<li><b>Weibull Wind Distribution:</b> Wind speeds follow a Weibull distribution (shape k=2.0, scale Œª=8.0 m/s)</li>
<li><b>Wake Effect:</b> Downstream turbines experience reduced wind speed based on distance from upwind turbines</li>
<li><b>Power Model:</b> Turbine power output: $P = 0.5 \times \rho \times A \times C_p \times v^3$<ul>
<li>$\rho$ = air density (1.225 kg/m¬≥)</li>
<li>$A$ = rotor area (œÄ √ó 25¬≤ m¬≤)</li>
<li>$C_p$ = power coefficient (0.4)</li>
<li>$v$ = effective wind speed</li>
</ul>
</li>
</ul>
<p><b>Algorithm Configuration:</b></p><ul>
<li><b>MH Integration:</b> 1500 samples, 400 burn-in, thinning factor 2</li>
<li><b>PSO:</b> 60 particles, 150 iterations, inertia=0.6, cognitive=1.8, social=2.0</li>
<li><b>GA:</b> 80 population, 200 generations, tournament_k=3, crossover=0.9, mutation=0.1</li>
</ul>
<p><b>Command line:</b> </p><div class="fragment"><div class="line">./wind_farm_simulator</div>
</div><!-- fragment --><p><b>Output Files:</b></p><ul>
<li><code>results_pso.dat</code> - Optimized turbine positions from PSO</li>
<li><code>results_ga.dat</code> - Optimized turbine positions from GA</li>
<li><code>plot_pso.gp</code> - Gnuplot script for PSO layout visualization</li>
<li><code>plot_ga.gp</code> - Gnuplot script for GA layout visualization</li>
<li><code>wind_farm_layout_pso.png</code> - PSO optimization result image</li>
<li><code>wind_farm_layout_ga.png</code> - GA optimization result image</li>
</ul>
<p><b>Visualization:</b> </p><div class="fragment"><div class="line">gnuplot plot_pso.gp  # Visualize PSO optimized wind farm layout</div>
<div class="line">gnuplot plot_ga.gp   # Visualize GA optimized wind farm layout</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
General Notes</h2>
<ul>
<li><b>Seed Control:</b> You can specify a custom random seed by running: <code>./montecarlo_1 &lt;seed&gt;</code></li>
<li><b>Parallelization:</b> PSO and drone_optimization support OpenMP parallelization. Control with:<ul>
<li><code>./montecarlo_1 &lt;seed&gt; &lt;num_threads&gt;</code> for montecarlo_1</li>
<li><code>./drone_optimization [seed|-] [num_threads]</code> for drone optimization</li>
<li>Use <code>0</code> for sequential execution, <code>N &gt; 0</code> for N threads</li>
<li>Use <code>-</code> as seed placeholder to keep default seed when specifying threads</li>
</ul>
</li>
<li><b>Output Organization:</b> Files are automatically saved to subdirectories (e.g., <code>drone_frames/</code> for the drone geometry outputs).</li>
<li><b>Visualization:</b><ul>
<li>Benchmark animations: <code>gnuplot run_pso.gp</code>, <code>run_pso_3d.gp</code>, <code>run_ga.gp</code>, <code>run_ga_3d.gp</code></li>
<li>Drone geometry: <code>gnuplot -persist visualize_drone.gp</code> (auto-generated after running drone_optimization)</li>
</ul>
</li>
<li><b>Closing Plots:</b> To close all gnuplot windows, run: <div class="fragment"><div class="line">pkill -f gnuplot</div>
</div><!-- fragment --></li>
</ul>
<p><img src="assets/wind_farm_layout_ga.png" alt="Wind Farm GA" width="48%" class="inline"/> <img src="assets/wind_farm_layout_pso.png" alt="Wind farm PSO" width="48%" class="inline"/> </p>
<h1><a class="anchor" id="autotoc_md13"></a>
üìù How to Write the Function (muParserX)</h1>
<p>Before compiling the program, enter the function to integrate in the function.txt file located in the root of the repository. <br  />
 Use standard mathematical notation such as:</p>
<ul>
<li><b>Variables:</b> Use the variable names defined in your code (e.g., <code>x</code>, <code>y</code>, <code>z</code> or <code>x[0]</code>, <code>x[1]</code>).</li>
<li><b>Operators:</b> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code> (power).</li>
<li><b>Common Functions:</b> <code>sin()</code>, <code>cos()</code>, <code>tan()</code>, <code>exp()</code>, <code>log()</code>, <code>sqrt()</code>, <code>abs()</code>.</li>
<li><b>Constants:</b> <code>_pi</code>, <code>_e</code>.</li>
</ul>
<p><b>Example Input:</b> </p><div class="fragment"><div class="line">sin(x) * exp(y) + (z^2 / 2)</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md14"></a>
How to set gnuplot on mac</h1>
<ol type="1">
<li>Open XQuartx and enter in its terminal: <div class="fragment"><div class="line">xhost +localhost</div>
</div><!-- fragment --></li>
<li>In container terminal enter: <div class="fragment"><div class="line">export DISPLAY=host.docker.internal:0</div>
<div class="line">gnuplot -persist -e &quot;set term x11&quot;</div>
</div><!-- fragment --> <br  />
</li>
</ol>
<h1><a class="anchor" id="autotoc_md15"></a>
Mathematical Background</h1>
<p>This library implements several Monte Carlo methods for numerical integration and stochastic optimization. Below is the mathematical formulation for the core algorithms used.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
1. Numerical Integration</h2>
<h3><a class="anchor" id="autotoc_md17"></a>
1.1 Classic Monte Carlo Integration</h3>
<p>The simplest Monte Carlo estimator approximates the integral of a function $f$ over a domain $\Omega$ by sampling points uniformly within a bounding box $B$ (where $\Omega \subseteq B$) and evaluating $f$.</p>
<p>$$I = \int_{\Omega} f(\mathbf{x}) \, d\mathbf{x} \approx V_B \cdot \frac{1}{N} \sum_{i=1}^{N} f(\mathbf{x}_i) \cdot \mathbb{1}_{\Omega}(\mathbf{x}_i)$$</p>
<p>Where:</p>
<ul>
<li>$V_B$ is the volume of the hyper-rectangle bounding the domain.</li>
<li>$\mathbf{x}_i$ are $N$ samples drawn uniformly from $B$.</li>
<li>$\mathbb{1}_{\Omega}(\mathbf{x})$ is the indicator function ($1$ if $\mathbf{x} \in \Omega$, $0$ otherwise).</li>
</ul>
<p><b>Implementation Details:</b> The method <code>integrate</code> generates random points in the bounding box. If a point falls inside the domain (checked via <code>domain.isInside(p)</code>), its contribution is added. Non-domain points effectively contribute 0.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
1.2 Importance Sampling</h3>
<p>Importance Sampling reduces variance by sampling points from a proposal distribution $q(\mathbf{x})$ that ideally resembles the shape of $f(\mathbf{x})$, rather than sampling uniformly.</p>
<p>$$I = \int_{\Omega} f(\mathbf{x}) \, d\mathbf{x} \approx \frac{1}{N} \sum_{i=1}^{N} \frac{f(\mathbf{x}_i)}{q(\mathbf{x}_i)}$$</p>
<p>Where:</p>
<ul>
<li>$\mathbf{x}_i$ are samples drawn from the probability density function (PDF) $q(\mathbf{x})$.</li>
<li>The term $\frac{f(\mathbf{x}_i)}{q(\mathbf{x}_i)}$ is the importance weight.</li>
</ul>
<p><b>Implementation Details:</b> The <code>ISMeanEstimator</code> computes the mean of the weighted samples. The <code>integrate_importance</code> method uses this estimator. Note that for the integration to be correct over the domain volume, the weights must be properly scaled relative to the domain measure.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
1.2.1 Proposal Distributions for Variance Reduction</h3>
<p>The quality of importance sampling depends critically on the choice of proposal distribution $q(\mathbf{x})$. The framework provides three pluggable proposal types, each optimized for different scenarios:</p>
<h4><a class="anchor" id="autotoc_md20"></a>
&lt;strong&gt;UniformProposal&lt;dim&gt;&lt;/strong&gt;</h4>
<p>Standard rejection sampling over the bounding box.</p>
<p>$$q(\mathbf{x}) = \frac{1}{V_B}, \quad \mathbf{x} \in B$$</p>
<p><b>Characteristics:</b></p><ul>
<li>Baseline strategy; no variance reduction</li>
<li>Zero computational overhead</li>
<li>Effective for box-like domains or as fallback</li>
<li>Importance weights are all 1.0 (no weighting needed)</li>
</ul>
<p><b>Use when:</b> Testing baseline performance or domain is roughly rectangular.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> proposal = <a class="code hl_class" href="classmc_1_1proposals_1_1UniformProposal.html">mc::proposals::UniformProposal&lt;3&gt;</a>{bounds};</div>
<div class="line"><span class="keyword">auto</span> integral = integrator.integrate_importance(domain, function, 100000, proposal);</div>
<div class="ttc" id="aclassmc_1_1proposals_1_1UniformProposal_html"><div class="ttname"><a href="classmc_1_1proposals_1_1UniformProposal.html">mc::proposals::UniformProposal</a></div><div class="ttdoc">Uniform distribution over a domain.</div><div class="ttdef"><b>Definition</b> <a href="uniformProposal_8hpp_source.html#l00031">uniformProposal.hpp:32</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md21"></a>
&lt;strong&gt;GaussianProposal&lt;dim&gt;&lt;/strong&gt;</h4>
<p>Isotropic Gaussian centered at domain centroid. Reduces variance when the integrand is smooth and bell-shaped.</p>
<p>$$q(\mathbf{x}) = \frac{1}{(2\pi\sigma^2)^{d/2}} \exp\left(-\frac{|\mathbf{x}-\boldsymbol{\mu}|^2}{2\sigma^2}\right)$$</p>
<p><b>Characteristics:</b></p><ul>
<li>Concentrates samples near domain center</li>
<li>Excellent variance reduction for smooth functions</li>
<li>Requires tuning $\sigma$ (standard deviation)</li>
<li>Importance weights: $w(\mathbf{x}) = \frac{f(\mathbf{x})}{q(\mathbf{x})}$ can grow exponentially in high dimensions ("curse of dimensionality")</li>
</ul>
<p><b>Best for:</b> Low-to-medium dimensions (d &lt; 10), smooth smooth integrands (e.g., Gaussians, polynomials).</p>
<p><b>Parameter guidance:</b></p><ul>
<li>$\sigma$ too small ‚Üí most samples near center, high variance in weights</li>
<li>$\sigma$ too large ‚Üí proposal ‚âà uniform, little variance reduction</li>
<li>Optimal: $\sigma \approx$ domain radius / 3</li>
</ul>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> center = domain.getBounds().center();  <span class="comment">// Domain centroid</span></div>
<div class="line"><span class="keywordtype">double</span> sigma = domain.getBounds().radius() / 3.0;</div>
<div class="line"><span class="keyword">auto</span> proposal = <a class="code hl_class" href="classmc_1_1proposals_1_1GaussianProposal.html">mc::proposals::GaussianProposal&lt;3&gt;</a>{center, sigma};</div>
<div class="line"><span class="keyword">auto</span> integral = integrator.integrate_importance(domain, function, 100000, proposal);</div>
<div class="ttc" id="aclassmc_1_1proposals_1_1GaussianProposal_html"><div class="ttname"><a href="classmc_1_1proposals_1_1GaussianProposal.html">mc::proposals::GaussianProposal</a></div><div class="ttdef"><b>Definition</b> <a href="gaussianProposal_8hpp_source.html#l00032">gaussianProposal.hpp:33</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md22"></a>
&lt;strong&gt;MixtureProposal&lt;dim&gt;&lt;/strong&gt;</h4>
<p>Convex combination of Gaussian and Uniform proposals. Balances exploitation (Gaussian focus) with exploration (Uniform coverage).</p>
<p>$$q(\mathbf{x}) = \lambda \cdot q_{\text{Gauss}}(\mathbf{x}) + (1-\lambda) \cdot q_{\text{Uniform}}(\mathbf{x}), \quad \lambda \in [0,1]$$</p>
<p><b>Characteristics:</b></p><ul>
<li>Combines benefits: concentration + robustness</li>
<li>Flexible via mixture weight $\lambda$</li>
<li>Handles non-standard integrands gracefully</li>
<li>Reduced weight explosion vs pure Gaussian in high dimensions</li>
</ul>
<p><b>Best for:</b> Medium-high dimensions (d = 5‚Äì20), unknown/non-smooth integrands.</p>
<p><b>Parameter guidance:</b></p><ul>
<li>$\lambda = 0.8$: Mostly Gaussian, some fallback to Uniform (default)</li>
<li>$\lambda = 0.5$: Equal balance (safe default)</li>
<li>$\lambda = 0.2$: Mostly Uniform with slight Gaussian focus (conservative)</li>
</ul>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> center = domain.getBounds().center();</div>
<div class="line"><span class="keywordtype">double</span> sigma = domain.getBounds().radius() / 3.0;</div>
<div class="line"><span class="keywordtype">double</span> mixture_weight = 0.7;  <span class="comment">// 70% Gaussian, 30% Uniform</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> gaussian = std::make_shared&lt;mc::proposals::GaussianProposal&lt;3&gt;&gt;(center, sigma);</div>
<div class="line"><span class="keyword">auto</span> uniform = std::make_shared&lt;mc::proposals::UniformProposal&lt;3&gt;&gt;(bounds);</div>
<div class="line"><span class="keyword">auto</span> proposal = <a class="code hl_class" href="classmc_1_1proposals_1_1MixtureProposal.html">mc::proposals::MixtureProposal&lt;3&gt;</a>{mixture_weight, gaussian, uniform};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> integral = integrator.integrate_importance(domain, function, 100000, proposal);</div>
<div class="ttc" id="aclassmc_1_1proposals_1_1MixtureProposal_html"><div class="ttname"><a href="classmc_1_1proposals_1_1MixtureProposal.html">mc::proposals::MixtureProposal</a></div><div class="ttdef"><b>Definition</b> <a href="mixtureProposal_8hpp_source.html#l00036">mixtureProposal.hpp:37</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md23"></a>
&lt;strong&gt;Proposal Comparison Table&lt;/strong&gt;</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Proposal   </th><th class="markdownTableHeadNone">Variance Reduction   </th><th class="markdownTableHeadNone">Dimension Scaling   </th><th class="markdownTableHeadNone">Tuning Effort   </th><th class="markdownTableHeadNone">Recommendation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Uniform</b>   </td><td class="markdownTableBodyNone">None (baseline)   </td><td class="markdownTableBodyNone">O(1)   </td><td class="markdownTableBodyNone">Zero   </td><td class="markdownTableBodyNone">Baseline, testing    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Gaussian</b>   </td><td class="markdownTableBodyNone">High (if $\sigma$ well-tuned)   </td><td class="markdownTableBodyNone">Degrades in high-d   </td><td class="markdownTableBodyNone">Medium (œÉ tuning)   </td><td class="markdownTableBodyNone">d &lt; 10, smooth f    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Mixture</b>   </td><td class="markdownTableBodyNone">Medium-High   </td><td class="markdownTableBodyNone">Better high-d scaling   </td><td class="markdownTableBodyNone">Low (robust defaults)   </td><td class="markdownTableBodyNone">d = 5‚Äì20, unknown f   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md24"></a>
&lt;strong&gt;When to Use Which Proposal&lt;/strong&gt;</h4>
<div class="fragment"><div class="line">Does your function have a &quot;peak&quot; or region of high values?</div>
<div class="line">‚îú‚îÄ YES ‚Üí Use Gaussian or Mixture</div>
<div class="line">‚îÇ   ‚îî‚îÄ Is dimension d &lt; 10?</div>
<div class="line">‚îÇ       ‚îú‚îÄ YES ‚Üí Use Gaussian (with tuned œÉ)</div>
<div class="line">‚îÇ       ‚îî‚îÄ NO ‚Üí Use Mixture (more robust)</div>
<div class="line">‚îî‚îÄ NO ‚Üí Use Uniform (baseline)</div>
<div class="line"> </div>
<div class="line">Is your integrand oscillatory or has multiple peaks?</div>
<div class="line">‚îî‚îÄ YES ‚Üí Use Mixture or Uniform (Gaussian may focus on one peak)</div>
<div class="line"> </div>
<div class="line">Do you know the integrand shape a priori?</div>
<div class="line">‚îú‚îÄ YES ‚Üí Tune Gaussian; likely best performance</div>
<div class="line">‚îî‚îÄ NO ‚Üí Use Mixture (safe, automatic tuning-free)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
1.3 Metropolis-Hastings Integration</h3>
<p>This method is effective for complex domains where simple uniform sampling is inefficient. It separates the problem into two parts: estimating the domain volume and estimating the function mean.</p>
<ol type="1">
<li><b>Volume Estimation ($V_{\Omega}$):</b> Computed using Hit-or-Miss Monte Carlo (see section 3).</li>
<li>**Mean Estimation ($\bar{f}$):** Uses the Metropolis-Hastings (MH) algorithm to generate a Markov Chain of samples distributed according to a target density $\pi(\mathbf{x})$ (typically uniform over $\Omega$).</li>
</ol>
<p>$$I = V_{\Omega} \cdot \bar{f} \quad \text{where} \quad \bar{f} = \frac{1}{N} \sum_{i=1}^{N} f(\mathbf{x}_i)$$</p>
<p>Where $\mathbf{x}_i$ are samples generated by the MH sampler. The sampler accepts a candidate $\mathbf{x}'$ from current state $\mathbf{x}$ with probability:</p>
<p>$$\alpha = \min\left(1, \frac{\pi(\mathbf{x}')}{\pi(\mathbf{x})}\right)$$</p>
<p>(Note: The proposal distribution in the random walk is symmetric, so the Hastings ratio $\frac{q(\mathbf{x}|\mathbf{x}')}{q(\mathbf{x}'|\mathbf{x})}$ cancels out).</p>
<p><b>Implementation Details:</b> The method <code>integrate_with_mh</code> first calls <code>VolumeEstimatorMC</code> to find $V_{\Omega}$. Then it runs a <code>MetropolisHastingsSampler</code> to gather samples $\mathbf{x}_i$ inside $\Omega$ and computes their average $\bar{f}$.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
2. Optimization Algorithms</h2>
<h3><a class="anchor" id="autotoc_md27"></a>
2.1 Particle Swarm Optimization (PSO)</h3>
<p>PSO optimizes a function by simulating a swarm of particles moving through the search space. Each particle $i$ has a position $\mathbf{x}_i$ and velocity $\mathbf{v}_i$. They are updated based on:</p>
<ol type="1">
<li><b>Inertia:</b> The particle's previous velocity.</li>
<li><b>Cognitive Component:</b> The distance to the particle's own best known position ($\mathbf{p}_i$).</li>
<li><b>Social Component:</b> The distance to the swarm's global best known position ($\mathbf{g}$).</li>
</ol>
<p><b>Update Equations:</b></p>
<p>$$\mathbf{v}_i(t+1) = w \cdot \mathbf{v}_i(t) + c_1 \cdot r_1 \cdot (\mathbf{p}_i - \mathbf{x}_i(t)) + c_2 \cdot r_2 \cdot (\mathbf{g} - \mathbf{x}_i(t))$$</p>
<p>$$\mathbf{x}_i(t+1) = \mathbf{x}_i(t) + \mathbf{v}_i(t+1)$$</p>
<p>Where:</p>
<ul>
<li>$w$: Inertia weight.</li>
<li>$c_1, c_2$: Cognitive and social coefficients.</li>
<li>$r_1, r_2$: Random numbers in $[0,1]$.</li>
</ul>
<p><b>Implementation Details:</b> Found in <code><a class="el" href="PSO_8cpp.html" title="Particle Swarm Optimization implementation.">PSO.cpp</a></code>, the <code>step()</code> function applies these updates and enforces boundary constraints (damping velocity if a boundary is hit).</p>
<h3><a class="anchor" id="autotoc_md28"></a>
2.2 Genetic Algorithm (GA)</h3>
<p>GA evolves a population of candidate solutions using biologically inspired operators.</p>
<ol type="1">
<li><b>Selection (Tournament):</b> $k$ individuals are chosen at random, and the best one is selected for reproduction.</li>
<li><b>Crossover (Uniform):</b> Two parents swap genes (coordinates) with probability $p_c$ per dimension to create offspring.</li>
<li><b>Mutation (Gaussian):</b> Each gene is perturbed by a Gaussian noise $\mathcal{N}(0, \sigma^2)$ with a small probability.</li>
<li><b>Elitism:</b> The top $n_e$ best individuals are carried over unchanged to the next generation.</li>
</ol>
<p><b>Implementation Details:</b> Found in <code><a class="el" href="GA_8cpp.html" title="Genetic Algorithm implementation.">GA.cpp</a></code>, implementing tournament selection, uniform crossover, and Gaussian mutation within the <code>step()</code> loop.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
3. Volume Estimation</h2>
<p>The volume of an integration domain $\Omega$ is estimated using a Hit-or-Miss approach. By enclosing $\Omega$ in a bounding box $B$ of known volume $V_B$:</p>
<p>$$V_{\Omega} \approx V_B \cdot \frac{N_{\text{hits}}}{N_{\text{total}}}$$</p>
<p>The standard error of this estimate is derived from the variance of the Bernoulli distribution (inside/outside):</p>
<p>$$\sigma_V = V_B \cdot \sqrt{\frac{p(1-p)}{N}}$$</p>
<p>Where $p = \frac{N_{\text{hits}}}{N_{\text{total}}}$.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
üìê Using Qhull for Polytopes</h2>
<p>The program also supports Monte Carlo integration over convex polytopes in any dimension. To define a polytope, you provide a set of points and let Qhull compute its convex hull, including facet normals and offsets.</p>
<p><b>1Ô∏è‚É£ Create the input file points.txt</b></p>
<p>The format must be:</p>
<div class="fragment"><div class="line">&lt;num_points&gt; &lt;dim&gt;</div>
<div class="line">x‚ÇÅ y‚ÇÅ z‚ÇÅ</div>
<div class="line">x‚ÇÇ y‚ÇÇ z‚ÇÇ</div>
<div class="line">...</div>
</div><!-- fragment --><p> Example for 3D:</p>
<div class="fragment"><div class="line">10 3</div>
<div class="line">0.1 0.3 0.5</div>
<div class="line">0.2 0.8 0.4</div>
<div class="line">...</div>
</div><!-- fragment --><p><b>2Ô∏è‚É£ Compute the convex hull (normals + offsets)</b></p>
<p>Use Qhull with the n option to output facet normals and plane offsets:</p>
<div class="fragment"><div class="line">module load qhull</div>
<div class="line">qhull Qt n &lt; points.txt &gt; hull.txt</div>
</div><!-- fragment --><p> Where: ‚Ä¢ Qt ‚Üí triangulates the hull ‚Ä¢ n ‚Üí prints one facet normal per line, followed by its offset d ‚Ä¢ Qhull outputs hyperplanes in the form</p>
<p>n ¬∑ x + d = 0</p>
<p>and the program internally converts them to</p>
<p>n' ¬∑ x ‚â§ b</p>
<p>which defines the half-spaces forming the convex polytope.</p>
<p><b>3Ô∏è‚É£ Run the program in polytope mode</b> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
