// gaussianProposal.hpp
/**
 * @file gaussianProposal.hpp
 * @brief Diagonal multivariate Gaussian proposal over a generic integration domain.
 *
 * Draws samples from N(mu, diag(sigma^2)) and enforces x ∈ D via rejection:
 *   sample x ~ N(...)
 *   while x ∉ D: resample
 *
 * IMPORTANT NOTE ABOUT NORMALIZATION:
 * Rejection induces a truncated Gaussian on D:
 *   q_trunc(x) = phi(x) * 1_D(x) / Z,  Z = P(X ∈ D)
 * For generic domains Z is hard to compute. Therefore pdf() returns
 * the UNNORMALIZED density: phi(x) * 1_D(x).
 * This is fine for self-normalized IS/MIS where the unknown constant cancels.
 */

#ifndef MONTECARLO_1_GAUSSIAN_PROPOSAL_HPP
#define MONTECARLO_1_GAUSSIAN_PROPOSAL_HPP

#include "proposal.hpp"
#include "../domains/integration_domain.hpp"

#include <array>
#include <cmath>
#include <random>
#include <vector>
#include <limits>
#include <type_traits>
#include <utility>

template <size_t dim>
class GaussianProposal : public Proposal<dim>
{
public:
    GaussianProposal(const IntegrationDomain<dim>& d,
                     const std::vector<double>& mean,
                     const std::vector<double>& sigma);

    /**
     * @brief Pilot-adapted Gaussian proposal from an integrand.
     *
     * Estimates per-dimension mean/variance using self-normalized weights w(x)=|f(x)|
     * from pilot samples generated by an INITIAL diagonal Gaussian (init_mean/init_sigma),
     * enforced on the domain by rejection. Then builds the final diagonal Gaussian.
     *
     * This constructor is designed to be compatible with ISintegrator:
     * you can build the proposal by passing f once here, and then pass the proposal
     * to integrate(f, ..., proposal, ...).
     *
     * @tparam Func Callable: double f(const geom::Point<dim>&)
     * @param d Integration domain
     * @param f Integrand (used only for pilot moment estimation)
     * @param rng RNG used for pilot sampling (does not store rng)
     * @param n_pilot Number of pilot samples (effective samples may be fewer)
     * @param init_mean Initial Gaussian mean (size dim) used to generate pilot samples
     * @param init_sigma Initial Gaussian stddev (size dim) used to generate pilot samples
     * @param eps_sigma Floor added to sigma to avoid degeneracy
     */
    template <class Func>
    GaussianProposal(const IntegrationDomain<dim>& d,
                     Func&& f,
                     std::mt19937& rng,
                     std::size_t n_pilot,
                     const std::vector<double>& init_mean,
                     const std::vector<double>& init_sigma,
                     double eps_sigma = 1e-6);

    geom::Point<dim> sample(std::mt19937& rng) const override;

    double pdf(const geom::Point<dim>& x) const override;

private:
    const IntegrationDomain<dim>& domain;

    std::vector<double> mu;
    std::vector<double> sig;
    std::vector<double> inv_sig2;     // 1/sigma^2 for each dimension

    double log_norm_const = 0.0;      // log((2pi)^(-d/2) * prod(1/sigma_i))

    // One normal distribution per dimension (diagonal covariance).
    mutable std::array<std::normal_distribution<double>, dim> ndist{};

    // Helper: init ndist/inv_sig2/log_norm_const from mu/sig
    void init_from_mu_sig_();

    // Helper: estimate mu/sig from f using pilot samples
    template <class Func>
    void estimate_moments_from_function_(Func&& f,
                                         std::mt19937& rng,
                                         std::size_t n_pilot,
                                         const std::vector<double>& init_mean,
                                         const std::vector<double>& init_sigma,
                                         double eps_sigma);
};

#include "gaussianProposal.tpp"

#endif // MONTECARLO_1_GAUSSIAN_PROPOSAL_HPP